/**
 * üîÑ GESTOR DE SESIONES PERSISTENTES
 * Mantiene la conexi√≥n de WhatsApp activa en segundo plano
 * Reconecta autom√°ticamente si se pierde la conexi√≥n
 */

import { BaileysService } from './baileys-service'
import { db } from './db'

export class SessionManager {
  private static reconnectIntervals: Map<string, NodeJS.Timeout> = new Map()
  private static isInitialized = false

  /**
   * Inicializar el gestor de sesiones al arrancar el servidor
   */
  static async initialize() {
    if (this.isInitialized) {
      console.log('[SessionManager] Ya est√° inicializado')
      return
    }

    console.log('[SessionManager] üöÄ Inicializando gestor de sesiones...')

    try {
      // Buscar todas las conexiones que deber√≠an estar activas
      const activeConnections = await db.whatsAppConnection.findMany({
        where: {
          OR: [
            { status: 'CONNECTED' },
            { isConnected: true }
          ]
        }
      })

      console.log(`[SessionManager] Encontradas ${activeConnections.length} conexiones activas`)

      // Reconectar cada una
      for (const connection of activeConnections) {
        await this.restoreSession(connection.userId)
      }

      // Configurar verificaci√≥n peri√≥dica cada 5 minutos
      setInterval(() => {
        this.checkAllSessions()
      }, 5 * 60 * 1000)

      this.isInitialized = true
      console.log('[SessionManager] ‚úÖ Gestor de sesiones inicializado')

    } catch (error) {
      console.error('[SessionManager] ‚ùå Error inicializando:', error)
    }
  }

  /**
   * Restaurar sesi√≥n de un usuario
   */
  static async restoreSession(userId: string) {
    try {
      console.log(`[SessionManager] üîÑ Restaurando sesi√≥n para usuario: ${userId}`)

      // Verificar si ya existe una sesi√≥n activa en memoria
      const existingSession = BaileysService.getConnectionStatus(userId)
      
      if (existingSession && existingSession.status === 'CONNECTED') {
        console.log(`[SessionManager] ‚úÖ Sesi√≥n ya activa para: ${userId}`)
        return
      }

      // Intentar reconectar
      const result = await BaileysService.initializeConnection(userId)

      if (result.success || result.qr) {
        console.log(`[SessionManager] ‚úÖ Sesi√≥n restaurada para: ${userId}`)
        
        // Configurar reconexi√≥n autom√°tica si se desconecta
        this.setupAutoReconnect(userId)
      } else {
        console.log(`[SessionManager] ‚ö†Ô∏è No se pudo restaurar sesi√≥n para: ${userId}`)
        
        // Actualizar estado en DB
        await db.whatsAppConnection.update({
          where: { userId },
          data: {
            status: 'DISCONNECTED',
            isConnected: false
          }
        })
      }

    } catch (error) {
      console.error(`[SessionManager] ‚ùå Error restaurando sesi√≥n para ${userId}:`, error)
    }
  }

  /**
   * Configurar reconexi√≥n autom√°tica
   */
  static setupAutoReconnect(userId: string) {
    // Limpiar intervalo anterior si existe
    const existingInterval = this.reconnectIntervals.get(userId)
    if (existingInterval) {
      clearInterval(existingInterval)
    }

    // Verificar conexi√≥n cada 30 segundos (m√°s frecuente)
    const interval = setInterval(async () => {
      try {
        // Verificar en memoria primero
        const session = BaileysService.getConnectionStatus(userId)
        
        if (!session || session.status !== 'CONNECTED') {
          console.log(`[SessionManager] ‚ö†Ô∏è Sesi√≥n no activa en memoria, verificando DB...`)
          
          const connection = await db.whatsAppConnection.findUnique({
            where: { userId }
          })

          if (connection && (connection.status === 'CONNECTED' || connection.isConnected)) {
            console.log(`[SessionManager] üîÑ Reconectando usuario: ${userId}`)
            await this.restoreSession(userId)
          }
        }
      } catch (error) {
        console.error(`[SessionManager] Error en auto-reconexi√≥n para ${userId}:`, error)
      }
    }, 30 * 1000) // Cada 30 segundos

    this.reconnectIntervals.set(userId, interval)
    console.log(`[SessionManager] ‚è∞ Auto-reconexi√≥n configurada para: ${userId} (cada 30 seg)`)
  }

  /**
   * Verificar todas las sesiones activas
   */
  static async checkAllSessions() {
    try {
      console.log('[SessionManager] üîç Verificando todas las sesiones...')

      const connections = await db.whatsAppConnection.findMany({
        where: {
          OR: [
            { status: 'CONNECTED' },
            { isConnected: true }
          ]
        }
      })

      for (const connection of connections) {
        const session = BaileysService.getConnectionStatus(connection.userId)
        
        if (!session || session.status !== 'CONNECTED') {
          console.log(`[SessionManager] ‚ö†Ô∏è Sesi√≥n perdida para ${connection.userId}, reconectando...`)
          await this.restoreSession(connection.userId)
        }
      }

      console.log('[SessionManager] ‚úÖ Verificaci√≥n completada')

    } catch (error) {
      console.error('[SessionManager] Error verificando sesiones:', error)
    }
  }

  /**
   * Detener auto-reconexi√≥n para un usuario
   */
  static stopAutoReconnect(userId: string) {
    const interval = this.reconnectIntervals.get(userId)
    if (interval) {
      clearInterval(interval)
      this.reconnectIntervals.delete(userId)
      console.log(`[SessionManager] ‚èπÔ∏è Auto-reconexi√≥n detenida para: ${userId}`)
    }
  }

  /**
   * Limpiar todos los intervalos
   */
  static cleanup() {
    console.log('[SessionManager] üßπ Limpiando intervalos...')
    
    for (const [userId, interval] of Array.from(this.reconnectIntervals.entries())) {
      clearInterval(interval)
      console.log(`[SessionManager] Intervalo limpiado para: ${userId}`)
    }
    
    this.reconnectIntervals.clear()
    this.isInitialized = false
  }
}

// Inicializar autom√°ticamente cuando se importa el m√≥dulo
if (typeof window === 'undefined') {
  // Solo en el servidor
  SessionManager.initialize().catch(console.error)
}
