/**
 * Sistema de Auto-Recuperaci√≥n Inteligente
 * Detecta, diagnostica y corrige errores autom√°ticamente usando IA
 */

import { PrismaClient } from '@prisma/client'
import Groq from 'groq-sdk'

const prisma = new PrismaClient()
const groq = new Groq({ apiKey: process.env.GROQ_API_KEY })

interface RecoveryLog {
    timestamp: Date
    component: string
    error: string
    diagnosis: string
    action: string
    success: boolean
}

const recoveryLogs: RecoveryLog[] = []

export class AutoRecoveryService {

    /**
     * Diagnostica un error usando IA
     */
    static async diagnoseError(component: string, error: any): Promise<string> {
        try {
            const errorMessage = error?.message || error?.toString() || 'Error desconocido'
            const errorStack = error?.stack || 'Sin stack trace'

            const prompt = `Eres un experto en diagn√≥stico de errores de sistemas. Analiza este error y proporciona un diagn√≥stico conciso:

Componente: ${component}
Error: ${errorMessage}
Stack: ${errorStack}

Proporciona:
1. Causa probable del error
2. Soluci√≥n recomendada
3. Acci√≥n espec√≠fica a tomar

Responde en formato JSON:
{
  "causa": "descripci√≥n breve",
  "solucion": "qu√© hacer",
  "accion": "comando o c√≥digo espec√≠fico"
}`

            const response = await groq.chat.completions.create({
                model: 'llama-3.1-70b-versatile',
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.3,
                max_tokens: 500
            })

            const diagnosis = response.choices[0]?.message?.content || 'No se pudo diagnosticar'
            return diagnosis
        } catch (err) {
            console.error('Error en diagn√≥stico IA:', err)
            return 'Error al diagnosticar con IA'
        }
    }

    /**
     * Auto-recuperaci√≥n de WhatsApp
     */
    static async recoverWhatsApp(): Promise<boolean> {
        console.log('üîÑ Iniciando auto-recuperaci√≥n de WhatsApp...')

        try {
            // 1. Verificar estado actual
            const statusResponse = await fetch('http://localhost:3000/api/whatsapp/status')
            const status = await statusResponse.json()

            if (status.connected) {
                console.log('‚úÖ WhatsApp ya est√° conectado')
                return true
            }

            // 2. Intentar desconectar sesi√≥n corrupta
            console.log('üîß Limpiando sesi√≥n corrupta...')
            try {
                await fetch('http://localhost:3000/api/whatsapp/disconnect', { method: 'POST' })
                await new Promise(resolve => setTimeout(resolve, 2000))
            } catch (err) {
                console.log('‚ö†Ô∏è  No se pudo desconectar (puede que no haya sesi√≥n)')
            }

            // 3. Limpiar archivos de sesi√≥n
            const fs = await import('fs')
            const path = await import('path')
            const sessionDir = path.join(process.cwd(), 'auth_sessions')

            if (fs.existsSync(sessionDir)) {
                console.log('üóëÔ∏è  Eliminando archivos de sesi√≥n antiguos...')
                const files = fs.readdirSync(sessionDir)
                for (const file of files) {
                    fs.unlinkSync(path.join(sessionDir, file))
                }
            }

            // 4. Intentar reconectar
            console.log('üîå Intentando reconectar...')
            const connectResponse = await fetch('http://localhost:3000/api/whatsapp/connect', {
                method: 'POST'
            })

            const connectResult = await connectResponse.json()

            if (connectResult.success || connectResult.qr) {
                console.log('‚úÖ WhatsApp listo para escanear QR')
                this.logRecovery('WhatsApp', 'Conexi√≥n fallida', 'Sesi√≥n limpiada y lista para reconectar', 'Limpiar sesi√≥n y generar nuevo QR', true)
                return true
            }

            return false
        } catch (error) {
            console.error('‚ùå Error en auto-recuperaci√≥n de WhatsApp:', error)
            const diagnosis = await this.diagnoseError('WhatsApp', error)
            this.logRecovery('WhatsApp', error, diagnosis, 'Fall√≥ la recuperaci√≥n autom√°tica', false)
            return false
        }
    }

    /**
     * Auto-recuperaci√≥n de Base de Datos
     */
    static async recoverDatabase(): Promise<boolean> {
        console.log('üîÑ Iniciando auto-recuperaci√≥n de Base de Datos...')

        try {
            // 1. Verificar conexi√≥n
            await prisma.$connect()
            console.log('‚úÖ Conexi√≥n a base de datos OK')

            // 2. Verificar integridad de productos
            const productCount = await prisma.product.count()
            console.log(`üì¶ Productos en DB: ${productCount}`)

            if (productCount === 0) {
                console.log('‚ö†Ô∏è  No hay productos, importando cat√°logo...')
                // Importar productos b√°sicos
                const { execSync } = await import('child_process')
                execSync('npx tsx scripts/import-productos-completos.ts', { stdio: 'inherit' })

                this.logRecovery('Database', 'Sin productos', 'Base de datos vac√≠a', 'Importar cat√°logo completo', true)
                return true
            }

            // 3. Verificar productos sin im√°genes
            const productsWithoutImages = await prisma.product.count({
                where: {
                    OR: [
                        { images: null },
                        { images: '' },
                        { images: '[]' }
                    ]
                }
            })

            if (productsWithoutImages > 10) {
                console.log(`‚ö†Ô∏è  ${productsWithoutImages} productos sin im√°genes, restaurando...`)
                const { execSync } = await import('child_process')
                execSync('npx tsx scripts/restaurar-imagenes-megacomputer.ts', { stdio: 'inherit' })

                this.logRecovery('Database', 'Productos sin im√°genes', `${productsWithoutImages} productos sin im√°genes`, 'Restaurar im√°genes de MegaComputer', true)
            }

            return true
        } catch (error) {
            console.error('‚ùå Error en auto-recuperaci√≥n de DB:', error)
            const diagnosis = await this.diagnoseError('Database', error)
            this.logRecovery('Database', error, diagnosis, 'Fall√≥ la recuperaci√≥n autom√°tica', false)
            return false
        }
    }

    /**
     * Auto-recuperaci√≥n de Sistema de Pagos
     */
    static async recoverPayments(): Promise<boolean> {
        console.log('üîÑ Iniciando auto-recuperaci√≥n de Pagos...')

        try {
            // 1. Verificar que existan las variables de entorno
            const hasGroq = !!process.env.GROQ_API_KEY
            const hasMercadoPago = !!process.env.MERCADOPAGO_ACCESS_TOKEN
            const hasPayPal = !!process.env.PAYPAL_CLIENT_ID

            console.log(`‚úÖ GROQ_API_KEY: ${hasGroq ? 'Configurado' : 'Faltante'}`)
            console.log(`‚ö†Ô∏è  MERCADOPAGO: ${hasMercadoPago ? 'Configurado' : 'Faltante'}`)
            console.log(`‚ö†Ô∏è  PAYPAL: ${hasPayPal ? 'Configurado' : 'Faltante'}`)

            // 2. Probar generaci√≥n de link de pago
            const testProduct = await prisma.product.findFirst()

            if (!testProduct) {
                console.log('‚ö†Ô∏è  No hay productos para probar pagos')
                return false
            }

            // Probar API de pagos
            const testPayment = await fetch('http://localhost:3000/api/payments/create-link', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    productId: testProduct.id,
                    productName: testProduct.name,
                    price: testProduct.price,
                    quantity: 1,
                    method: 'whatsapp'
                })
            })

            const result = await testPayment.json()

            if (result.paymentLink) {
                console.log('‚úÖ Sistema de pagos funcionando')
                this.logRecovery('Payments', 'Test de pagos', 'Sistema verificado', 'Generar link de prueba', true)
                return true
            }

            return false
        } catch (error) {
            console.error('‚ùå Error en auto-recuperaci√≥n de Pagos:', error)
            const diagnosis = await this.diagnoseError('Payments', error)
            this.logRecovery('Payments', error, diagnosis, 'Fall√≥ la recuperaci√≥n autom√°tica', false)
            return false
        }
    }

    /**
     * Auto-recuperaci√≥n de Servicios de IA
     */
    static async recoverAI(): Promise<boolean> {
        console.log('üîÑ Iniciando auto-recuperaci√≥n de IA...')

        try {
            // 1. Verificar API key
            if (!process.env.GROQ_API_KEY) {
                console.log('‚ùå GROQ_API_KEY no configurado')
                this.logRecovery('AI', 'API Key faltante', 'Variable de entorno no configurada', 'Configurar GROQ_API_KEY', false)
                return false
            }

            // 2. Probar conexi√≥n con Groq (con timeout m√°s largo)
            console.log('üß™ Probando Groq con timeout de 20 segundos...')

            const testPromise = groq.chat.completions.create({
                model: 'llama-3.1-8b-instant', // Modelo m√°s r√°pido para test
                messages: [{ role: 'user', content: 'Test' }],
                max_tokens: 10
            })

            const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Timeout')), 20000)
            )

            const testResponse = await Promise.race([testPromise, timeoutPromise]) as any
            const response = testResponse.choices[0]?.message?.content

            if (response) {
                console.log('‚úÖ Groq funcionando correctamente')
                this.logRecovery('AI', 'Test de IA', 'Groq respondi√≥ correctamente', 'Probar Groq API', true)
                return true
            }

            return false
        } catch (error: any) {
            console.error('‚ùå Error en Groq:', error.message)

            // Intentar con fallback a OpenRouter
            if (process.env.OPENROUTER_API_KEY) {
                console.log('üîÑ Intentando con OpenRouter como fallback...')
                try {
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'anthropic/claude-3.5-sonnet',
                            messages: [{ role: 'user', content: 'Test' }],
                            max_tokens: 10
                        })
                    })

                    if (response.ok) {
                        console.log('‚úÖ OpenRouter funcionando como fallback')
                        this.logRecovery('AI', 'Groq timeout', 'OpenRouter disponible como fallback', 'Usar OpenRouter', true)
                        return true
                    }
                } catch (fallbackError) {
                    console.log('‚ùå OpenRouter tambi√©n fall√≥')
                }
            }

            const diagnosis = await this.diagnoseError('AI', error)
            this.logRecovery('AI', error, diagnosis, 'Fall√≥ la recuperaci√≥n autom√°tica', false)
            return false
        }
    }

    /**
     * Monitoreo continuo y auto-recuperaci√≥n
     */
    static async startMonitoring(intervalMinutes: number = 5) {
        console.log(`üîç Iniciando monitoreo autom√°tico cada ${intervalMinutes} minutos...`)

        const monitor = async () => {
            console.log('\nüîç Ejecutando chequeo de salud del sistema...')

            const results = {
                whatsapp: await this.checkWhatsAppHealth(),
                database: await this.checkDatabaseHealth(),
                payments: await this.checkPaymentsHealth(),
                ai: await this.checkAIHealth()
            }

            // Auto-recuperar componentes con problemas
            if (!results.whatsapp) {
                console.log('‚ö†Ô∏è  WhatsApp con problemas, iniciando recuperaci√≥n...')
                await this.recoverWhatsApp()
            }

            if (!results.database) {
                console.log('‚ö†Ô∏è  Base de datos con problemas, iniciando recuperaci√≥n...')
                await this.recoverDatabase()
            }

            if (!results.payments) {
                console.log('‚ö†Ô∏è  Pagos con problemas, iniciando recuperaci√≥n...')
                await this.recoverPayments()
            }

            if (!results.ai) {
                console.log('‚ö†Ô∏è  IA con problemas, iniciando recuperaci√≥n...')
                await this.recoverAI()
            }

            console.log('‚úÖ Chequeo de salud completado\n')
        }

        // Ejecutar inmediatamente
        await monitor()

        // Ejecutar peri√≥dicamente
        setInterval(monitor, intervalMinutes * 60 * 1000)
    }

    /**
     * Chequeos de salud individuales
     */
    private static async checkWhatsAppHealth(): Promise<boolean> {
        try {
            const response = await fetch('http://localhost:3000/api/whatsapp/status')
            const status = await response.json()
            return status.connected || false
        } catch {
            return false
        }
    }

    private static async checkDatabaseHealth(): Promise<boolean> {
        try {
            await prisma.$queryRaw`SELECT 1`
            return true
        } catch {
            return false
        }
    }

    private static async checkPaymentsHealth(): Promise<boolean> {
        try {
            return !!process.env.GROQ_API_KEY
        } catch {
            return false
        }
    }

    private static async checkAIHealth(): Promise<boolean> {
        try {
            if (!process.env.GROQ_API_KEY) return false

            const test = await groq.chat.completions.create({
                model: 'llama-3.1-70b-versatile',
                messages: [{ role: 'user', content: 'test' }],
                max_tokens: 5
            })

            return !!test.choices[0]?.message?.content
        } catch {
            return false
        }
    }

    /**
     * Registrar recuperaci√≥n
     */
    private static logRecovery(component: string, error: any, diagnosis: string, action: string, success: boolean) {
        const log: RecoveryLog = {
            timestamp: new Date(),
            component,
            error: error?.message || error?.toString() || 'Error desconocido',
            diagnosis,
            action,
            success
        }

        recoveryLogs.push(log)

        // Mantener solo los √∫ltimos 100 logs
        if (recoveryLogs.length > 100) {
            recoveryLogs.shift()
        }

        console.log(`üìù Log de recuperaci√≥n: ${component} - ${success ? '√âXITO' : 'FALLO'}`)
    }

    /**
     * Obtener logs de recuperaci√≥n
     */
    static getRecoveryLogs(): RecoveryLog[] {
        return recoveryLogs
    }

    /**
     * Recuperaci√≥n completa del sistema
     */
    static async fullSystemRecovery(): Promise<void> {
        console.log('üöÄ INICIANDO RECUPERACI√ìN COMPLETA DEL SISTEMA\n')
        console.log('='.repeat(60))

        const results = {
            whatsapp: await this.recoverWhatsApp(),
            database: await this.recoverDatabase(),
            payments: await this.recoverPayments(),
            ai: await this.recoverAI()
        }

        console.log('\n' + '='.repeat(60))
        console.log('üìä RESULTADOS DE RECUPERACI√ìN:')
        console.log('='.repeat(60))
        console.log(`WhatsApp: ${results.whatsapp ? '‚úÖ OK' : '‚ùå FALLO'}`)
        console.log(`Database: ${results.database ? '‚úÖ OK' : '‚ùå FALLO'}`)
        console.log(`Payments: ${results.payments ? '‚úÖ OK' : '‚ùå FALLO'}`)
        console.log(`AI: ${results.ai ? '‚úÖ OK' : '‚ùå FALLO'}`)
        console.log('='.repeat(60) + '\n')

        const allOk = Object.values(results).every(r => r)

        if (allOk) {
            console.log('üéâ SISTEMA COMPLETAMENTE RECUPERADO\n')
        } else {
            console.log('‚ö†Ô∏è  ALGUNOS COMPONENTES REQUIEREN ATENCI√ìN MANUAL\n')
        }
    }
}
