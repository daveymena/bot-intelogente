/**
 * üß† SERVICIO DE INTELIGENCIA DE PRODUCTOS
 * Maneja respuestas espec√≠ficas e inteligentes sobre productos
 * ‚ú® CON TOLERANCIA A ERRORES DE ESCRITURA (Fuzzy Matching)
 */

import { db } from './db'
import { FuzzyMatchService } from './fuzzy-match-service'

export interface ProductIntent {
    type: 'info' | 'price' | 'link' | 'buy' | 'availability' | 'general'
    confidence: number
    keywords: string[]
}

export interface ProductResponse {
    text: string
    product: any
    intent: ProductIntent
    hasLinks: boolean
    links?: {
        info?: string
        buy?: string
    }
    images?: string[]
    isGeneralQuery?: boolean  // Nueva: indica si es b√∫squeda general
    matchingProducts?: any[]  // Nueva: productos que coinciden
    needsQualification?: boolean  // Nueva: necesita hacer preguntas
}

export class ProductIntelligenceService {
    /**
     * Extraer palabras clave del mensaje
     */
    private static extractKeywords(query: string): string[] {
        const queryLower = query.toLowerCase()

        // Palabras a ignorar (stop words) - AMPLIADO
        const stopWords = [
            'info', 'informaci√≥n', 'informacion', 'dame', 'el', 'la', 'los', 'las',
            'un', 'una', 'del', 'de', 'cu√°nto', 'cuanto', 'cuesta', 'precio',
            'quiero', 'deseo', 'necesito', 'busco', 'hay', 'tienes', 'tienen', 'tiene',
            'disponible', 'link', 'enlace', 'comprar', 'sobre', 'acerca', 'ese',
            'esa', 'esto', 'esta', 'para', 'por', 'con', 'sin', 'm√°s', 'mas',
            'sus', 'papeles', 'd√≠a', 'dia', 'documentos', 'garant√≠a', 'garantia',
            'color', 'colores', 'env√≠o', 'envio', 'entrega', 'pago', 'pagos',
            'm√©todos', 'metodos', 'forma', 'formas', 'como', 'c√≥mo', 'que', 'qu√©',
            'ver', 'veo', 'vea', 'veas', 'ves', 'fotos', 'foto', 'imagen', 'imagenes',
            'detalles', 'detalle', 'caracter√≠sticas', 'caracteristicas', 'especificaciones',
            'saber', 'conocer', 'mostrar', 'muestra', 'muestrame', 'mu√©strame',
            'enviar', 'envia', 'env√≠a', 'manda', 'mandar', 'pasa', 'pasar',
            'puedes', 'puede', 'podr√≠a', 'podria', 'podr√≠as', 'podrias',
            'gustar√≠a', 'gustaria', 'quisiera', 'me', 'te', 'le', 'nos', 'les',
            'si', 's√≠', 'no', 'tal', 'vez', 'quiz√°', 'quiz√°s', 'quiza', 'quizas'
        ]

        // Dividir en palabras y filtrar
        const words = queryLower
            .split(/\s+/)
            .map(word => word.replace(/[?¬ø!¬°.,;:]/g, '')) // Quitar puntuaci√≥n de cada palabra
            .filter(word => word.length > 2) // Palabras de m√°s de 2 caracteres
            .filter(word => !stopWords.includes(word))

        return words
    }

    /**
     * Buscar producto espec√≠fico en la base de datos
     */
    static async findProduct(query: string, userId: string): Promise<any | null> {
        try {
            console.log(`üîç [Product Intelligence] Buscando producto: "${query}"`)

            // Normalizar query con el nuevo normalizador
            const { TextNormalizer } = await import('./text-normalizer')
            const normalized = TextNormalizer.normalize(query)
            const queryLower = normalized.toLowerCase()

            console.log(`üî§ [Product Intelligence] Query normalizada: "${normalized}"`)

            // üîç CORRECCI√ìN DE ERRORES DE ESCRITURA (Fuzzy matching)
            const dictionary = FuzzyMatchService.getCommonProductTerms()
            const correctionResult = FuzzyMatchService.correctTypos(queryLower, dictionary, 0.7)
            
            if (correctionResult.corrections.length > 0) {
                console.log(`‚úèÔ∏è [Product Intelligence] Correcciones aplicadas:`)
                correctionResult.corrections.forEach(c => {
                    console.log(`   "${c.original}" ‚Üí "${c.corrected}" (${(c.similarity * 100).toFixed(0)}% similar)`)
                })
            }

            // Usar query corregida para b√∫squeda
            const correctedQuery = correctionResult.corrected
            console.log(`üîç [Product Intelligence] Query corregida: "${correctedQuery}"`)

            // Detectar intenci√≥n de producto
            const intent = TextNormalizer.detectProductIntent(correctedQuery)
            if (intent.isProductQuery) {
                console.log(`üéØ [Product Intelligence] Tipo de producto detectado: ${intent.productType || 'general'}`)
                console.log(`üîë [Product Intelligence] Keywords detectadas: ${intent.keywords.join(', ')}`)
            }

            // üéØ DETECTAR INTENCI√ìN DE MEGAPACKS
            const megapackIntent = FuzzyMatchService.detectMegapackIntent(correctedQuery)
            
            if (megapackIntent.isMegapackQuery) {
                console.log(`üéØ [Product Intelligence] Intenci√≥n de megapack detectada:`)
                console.log(`   - Quiere todos: ${megapackIntent.wantsAll}`)
                console.log(`   - N√∫mero espec√≠fico: ${megapackIntent.specificNumber || 'ninguno'}`)
                
                // Si quiere "todos los megapacks" o "pack completo"
                if (megapackIntent.wantsAll) {
                    console.log(`üì¶ [Product Intelligence] Usuario busca TODOS los megapacks`)
                    
                    // Buscar el producto que contenga "40" y "megapack"
                    const allMegapacks = await db.product.findMany({
                        where: {
                            userId,
                            status: 'AVAILABLE',
                            OR: [
                                { name: { contains: 'megapack', mode: 'insensitive' } },
                                { name: { contains: 'mega pack', mode: 'insensitive' } },
                                { description: { contains: 'megapack', mode: 'insensitive' } }
                            ]
                        }
                    })
                    
                    // Buscar el que tenga "40" en el nombre o descripci√≥n
                    const pack40 = allMegapacks.find(p => 
                        p.name.includes('40') || 
                        p.description?.includes('40') ||
                        p.name.toLowerCase().includes('completo') ||
                        p.description?.toLowerCase().includes('completo')
                    )
                    
                    if (pack40) {
                        console.log(`‚úÖ [Product Intelligence] Pack completo encontrado: ${pack40.name}`)
                        return pack40
                    }
                    
                    // Si no encuentra el pack de 40, devolver el primero
                    if (allMegapacks.length > 0) {
                        console.log(`‚ö†Ô∏è [Product Intelligence] No se encontr√≥ pack de 40, devolviendo primer megapack`)
                        return allMegapacks[0]
                    }
                }
                
                // Si busca un n√∫mero espec√≠fico
                if (megapackIntent.specificNumber) {
                    console.log(`üî¢ [Product Intelligence] Buscando Megapack ${megapackIntent.specificNumber}`)
                    
                    const specificPack = await db.product.findFirst({
                        where: {
                            userId,
                            status: 'AVAILABLE',
                            OR: [
                                { name: { contains: `megapack ${megapackIntent.specificNumber}`, mode: 'insensitive' } },
                                { name: { contains: `mega pack ${megapackIntent.specificNumber}`, mode: 'insensitive' } },
                                { name: { contains: `pack ${megapackIntent.specificNumber}`, mode: 'insensitive' } }
                            ]
                        }
                    })
                    
                    if (specificPack) {
                        console.log(`‚úÖ [Product Intelligence] Megapack espec√≠fico encontrado: ${specificPack.name}`)
                        return specificPack
                    }
                }
            }

            // Extraer palabras clave del mensaje corregido
            const keywords = this.extractKeywords(correctedQuery)
            console.log(`üîë [Product Intelligence] Palabras clave finales: ${keywords.join(', ')}`)

            // ‚ö†Ô∏è IMPORTANTE: Si no hay palabras clave significativas, NO buscar
            // Esto evita b√∫squedas incorrectas con mensajes gen√©ricos como "ver m√°s informaci√≥n"
            if (keywords.length === 0 && !megapackIntent.isMegapackQuery) {
                console.log(`‚ùå [Product Intelligence] No hay palabras clave significativas - usar contexto de memoria`)
                return null
            }

            // üö® DETECTAR SI BUSCA ESPEC√çFICAMENTE NUEVO O USADO
            const buscaUsado = queryLower.includes('usado') || 
                               queryLower.includes('usada') || 
                               queryLower.includes('segunda mano') ||
                               queryLower.includes('reacondicionado')
            
            const buscaNuevo = queryLower.includes('nuevo') || 
                               queryLower.includes('nueva') ||
                               queryLower.includes('0 km') ||
                               queryLower.includes('sin usar')

            console.log(`üîç [Product Intelligence] Filtro - Usado: ${buscaUsado}, Nuevo: ${buscaNuevo}`)

            // Obtener todos los productos disponibles
            const allProducts = await db.product.findMany({
                where: {
                    userId,
                    status: 'AVAILABLE'
                }
            })

            if (allProducts.length === 0) {
                console.log(`‚ùå [Product Intelligence] No hay productos disponibles`)
                return null
            }

            // üö® FILTRAR POR CONDICI√ìN SI SE ESPECIFIC√ì
            let filteredProducts = allProducts

            if (buscaUsado) {
                filteredProducts = allProducts.filter(p => {
                    const nameLower = p.name.toLowerCase()
                    const descLower = (p.description || '').toLowerCase()
                    const esUsado = nameLower.includes('usado') || 
                                    nameLower.includes('usada') ||
                                    descLower.includes('usado') ||
                                    descLower.includes('usada')
                    return esUsado
                })
                console.log(`üîç [Product Intelligence] Filtrados ${filteredProducts.length} productos USADOS`)
            } else if (buscaNuevo) {
                filteredProducts = allProducts.filter(p => {
                    const nameLower = p.name.toLowerCase()
                    const descLower = (p.description || '').toLowerCase()
                    const esUsado = nameLower.includes('usado') || 
                                    nameLower.includes('usada') ||
                                    descLower.includes('usado') ||
                                    descLower.includes('usada')
                    return !esUsado // Solo productos que NO son usados
                })
                console.log(`üîç [Product Intelligence] Filtrados ${filteredProducts.length} productos NUEVOS`)
            }

            if (filteredProducts.length === 0) {
                console.log(`‚ùå [Product Intelligence] No hay productos ${buscaUsado ? 'USADOS' : 'NUEVOS'} disponibles`)
                return null
            }

            // Buscar coincidencias espec√≠ficas primero (incluyendo palabras del mensaje original)
            const specificMatches = [
                { keywords: ['piano'], name: 'piano', searchIn: 'name' },
                { keywords: ['macbook', 'mac', 'apple'], name: 'macbook', searchIn: 'name' },
                { keywords: ['moto', 'pulsar', 'bajaj'], name: 'bajaj', searchIn: 'name' },
                { keywords: ['asus', 'vivobook'], name: 'asus', searchIn: 'name' },
                { keywords: ['laptop', 'laptops', 'portatil', 'computador', 'computadora'], name: 'laptop', searchIn: 'name' },
                { keywords: ['hp'], name: 'hp', searchIn: 'name' },
                { keywords: ['lenovo'], name: 'lenovo', searchIn: 'name' },
                { keywords: ['mega', 'pack', 'megapack'], name: 'mega pack', searchIn: 'name' }
            ]

            // Buscar por coincidencias espec√≠ficas (buscar en el mensaje original, no solo en keywords)
            for (const match of specificMatches) {
                const hasKeywordInQuery = match.keywords.some(kw => queryLower.includes(kw))
                if (hasKeywordInQuery) {
                    // Buscar producto que contenga el nombre en su nombre o descripci√≥n
                    // üö® USAR filteredProducts en lugar de allProducts
                    const found = filteredProducts.find(p => {
                        const nameLower = p.name.toLowerCase()
                        const descLower = (p.description || '').toLowerCase()
                        
                        // Para "laptop", buscar cualquier laptop
                        if (match.name === 'laptop') {
                            return nameLower.includes('laptop') || 
                                   nameLower.includes('asus') || 
                                   nameLower.includes('hp') || 
                                   nameLower.includes('lenovo') ||
                                   nameLower.includes('macbook') ||
                                   descLower.includes('laptop')
                        }
                        
                        // Buscar en nombre (ya est√° en min√∫sculas)
                        return nameLower.includes(match.name)
                    })
                    
                    if (found) {
                        console.log(`‚úÖ [Product Intelligence] Producto espec√≠fico encontrado: ${found.name}`)
                        return found
                    }
                }
            }

            // Buscar por cualquier palabra clave en nombre, descripci√≥n o tags
            // üö® USAR filteredProducts en lugar de allProducts
            // ‚ú® CON FUZZY MATCHING para tolerar errores de escritura
            const scoredProducts = filteredProducts.map(p => {
                let score = 0
                const nameLower = p.name.toLowerCase()
                const descLower = (p.description || '').toLowerCase()
                const tagsLower = (p.tags || '').toLowerCase()

                keywords.forEach(keyword => {
                    const keywordLower = keyword.toLowerCase()
                    
                    // Coincidencia exacta en nombre vale mucho m√°s
                    if (nameLower.includes(keywordLower)) {
                        score += 15
                    } else {
                        // üîç FUZZY MATCHING: Buscar palabras similares
                        const nameWords = nameLower.split(/\s+/)
                        for (const nameWord of nameWords) {
                            const similarity = FuzzyMatchService.calculateSimilarity(keywordLower, nameWord)
                            if (similarity >= 0.7) {
                                // Palabra similar encontrada
                                score += Math.floor(15 * similarity)
                                console.log(`üîç [Fuzzy] "${keywordLower}" ‚âà "${nameWord}" (${(similarity * 100).toFixed(0)}%)`)
                            }
                        }
                    }
                    
                    // B√∫squeda en descripci√≥n (exacta y fuzzy)
                    if (descLower.includes(keywordLower)) {
                        score += 3
                    } else if (FuzzyMatchService.fuzzySearch(keywordLower, descLower, 0.7)) {
                        score += 2
                    }
                    
                    // B√∫squeda en tags
                    if (tagsLower.includes(keywordLower)) score += 2
                    
                    // Bonus: coincidencia al inicio del nombre
                    if (nameLower.startsWith(keywordLower)) score += 5
                    
                    // Bonus: palabra completa en el nombre
                    const nameWords = nameLower.split(/\s+/)
                    if (nameWords.some(word => word === keywordLower)) score += 10
                })

                return { product: p, score }
            })

            // Ordenar por score y tomar el mejor
            // Score m√≠nimo reducido a 5 para ser m√°s flexible
            const bestMatch = scoredProducts
                .filter(sp => sp.score >= 5)
                .sort((a, b) => b.score - a.score)[0]

            if (bestMatch) {
                console.log(`‚úÖ [Product Intelligence] Producto encontrado: ${bestMatch.product.name} (score: ${bestMatch.score})`)
                return bestMatch.product
            }

            console.log(`‚ùå [Product Intelligence] No se encontraron productos con suficiente coincidencia (score m√≠nimo: 5)`)
            return null

        } catch (error) {
            console.error('‚ùå [Product Intelligence] Error buscando producto:', error)
            return null
        }
    }

    /**
     * Detectar la intenci√≥n del cliente
     */
    static detectIntent(message: string): ProductIntent {
        const messageLower = message.toLowerCase()

        // Intenci√≥n: LINK/ENLACE
        if (/(link|enlace|url|p√°gina|pagina|dame el|env√≠a|envia|manda|pasa).*(link|enlace|url|p√°gina|pagina)/i.test(messageLower) ||
            /^(link|enlace|url)$/i.test(messageLower)) {
            return {
                type: 'link',
                confidence: 0.95,
                keywords: ['link', 'enlace', 'url']
            }
        }

        // Intenci√≥n: COMPRAR
        if (/(quiero|deseo|me gustar√≠a|quisiera).*(comprar|adquirir|pedir|ordenar)/i.test(messageLower) ||
            /(comprar|compra|pedido|orden)/i.test(messageLower)) {
            return {
                type: 'buy',
                confidence: 0.95,
                keywords: ['comprar', 'pedido']
            }
        }

        // Intenci√≥n: PRECIO
        if (/(cu√°nto|cuanto|precio|cuesta|valor|vale|costo)/i.test(messageLower)) {
            return {
                type: 'price',
                confidence: 0.9,
                keywords: ['precio', 'cuesta']
            }
        }

        // Intenci√≥n: DISPONIBILIDAD
        if (/(disponible|stock|hay|tienen|tienes|queda|quedan)/i.test(messageLower)) {
            return {
                type: 'availability',
                confidence: 0.85,
                keywords: ['disponible', 'stock']
            }
        }

        // Intenci√≥n: INFORMACI√ìN
        if (/(info|informaci√≥n|informacion|detalles|caracter√≠sticas|caracteristicas|especificaciones|sobre|acerca)/i.test(messageLower)) {
            return {
                type: 'info',
                confidence: 0.9,
                keywords: ['info', 'detalles']
            }
        }

        // Por defecto: GENERAL
        return {
            type: 'general',
            confidence: 0.7,
            keywords: []
        }
    }

    /**
     * Extraer enlaces del producto (SOLO para productos digitales)
     */
    static extractLinks(product: any): { info?: string, buy?: string, mercadopago?: string, paypal?: string, contacto?: string } {
        const links: { info?: string, buy?: string, mercadopago?: string, paypal?: string, contacto?: string } = {}

        try {
            // Intentar parsear tags como JSON
            const tags = product.tags ? JSON.parse(product.tags) : []

            for (const tag of tags) {
                if (typeof tag === 'string') {
                    // Extraer tags con prefijos de m√©todos de pago
                    if (tag.startsWith('hotmart:')) {
                        links.buy = tag.replace('hotmart:', '')
                    } else if (tag.startsWith('mercadopago:')) {
                        links.mercadopago = tag.replace('mercadopago:', '')
                    } else if (tag.startsWith('paypal:')) {
                        links.paypal = tag.replace('paypal:', '')
                    } else if (tag.startsWith('contacto:')) {
                        links.contacto = tag.replace('contacto:', '')
                    } else if (tag.startsWith('http')) {
                        // URLs sin prefijo
                        if (tag.includes('pay.hotmart') || tag.includes('checkout') || tag.includes('buy')) {
                            links.buy = tag
                        } else if (tag.includes('landein') || tag.includes('page') || tag.includes('info')) {
                            links.info = tag
                        } else if (!links.info) {
                            links.info = tag
                        }
                    }
                }
            }
        } catch (e) {
            // Si no es JSON, buscar URLs en el string
            const urlRegex = /(https?:\/\/[^\s,]+)/g
            const matches = product.tags?.match(urlRegex) || []

            for (const url of matches) {
                if (url.includes('pay.hotmart') || url.includes('checkout')) {
                    links.buy = url
                } else if (!links.info) {
                    links.info = url
                }
            }
        }

        // ‚ö†Ô∏è SOLO GENERAR ENLACES PARA PRODUCTOS DIGITALES
        // Productos f√≠sicos NO tienen links de pago autom√°ticos
        if (product.category === 'DIGITAL') {
            // Si no tiene MercadoPago configurado, no generar
            // Solo usar los links que est√°n en los tags
            if (!links.buy && !links.mercadopago && !links.paypal) {
                // No generar links din√°micos, dejar vac√≠o
                // El bot ofrecer√° contacto directo
            }
        } else {
            // Productos f√≠sicos: NUNCA generar links de pago
            // Limpiar cualquier link que se haya extra√≠do por error
            links.buy = undefined
            links.mercadopago = undefined
            links.paypal = undefined
            
            // Agregar contacto directo
            links.contacto = '+57 304 274 8687'
        }

        return links
    }



    /**
     * Extraer im√°genes del producto
     */
    static extractImages(product: any): string[] {
        try {
            return product.images ? JSON.parse(product.images) : []
        } catch (e) {
            return []
        }
    }

    /**
     * Generar respuesta seg√∫n la intenci√≥n
     */
    static async generateResponse(
        product: any,
        intent: ProductIntent,
        context?: any
    ): Promise<ProductResponse> {
        const links = this.extractLinks(product)
        const images = this.extractImages(product)
        const hasLinks = !!(links.info || links.buy)

        // Emoji seg√∫n categor√≠a
        const emoji = this.getProductEmoji(product)

        let text = ''

        switch (intent.type) {
            case 'info':
                text = this.generateInfoResponse(product, emoji, links, images)
                break

            case 'price':
                text = this.generatePriceResponse(product, emoji, links)
                break

            case 'link':
                text = this.generateLinkResponse(product, emoji, links)
                break

            case 'buy':
                text = this.generateBuyResponse(product, emoji, links)
                break

            case 'availability':
                text = this.generateAvailabilityResponse(product, emoji)
                break

            default:
                text = this.generateGeneralResponse(product, emoji, links, images)
        }

        return {
            text,
            product,
            intent,
            hasLinks,
            links,
            images
        }
    }

    /**
     * Generar respuesta de INFORMACI√ìN
     */
    private static generateInfoResponse(product: any, emoji: string, links: any, images: string[]): string {
        let response = `${emoji} **${product.name}**\n\n`

        if (product.description) {
            // Extraer caracter√≠sticas si est√°n en formato de lista
            const lines = product.description.split(/[,\n]/).filter((l: string) => l.trim())
            if (lines.length > 1) {
                lines.slice(0, 5).forEach((line: string) => {
                    response += `‚úÖ ${line.trim()}\n`
                })
            } else {
                response += `${product.description}\n\n`
            }
        }

        response += `\nüí∞ Precio: $${product.price.toLocaleString('es-CO')} COP\n`

        if (product.stock) {
            response += `üì¶ ${product.stock} unidades disponibles\n`
        }

        if (images.length > 0) {
            response += `üì∏ ${images.length} foto${images.length > 1 ? 's' : ''} disponible${images.length > 1 ? 's' : ''}\n`
        }

        response += `\n¬øTe interesa?`

        return response
    }

    /**
     * Generar respuesta de PRECIO
     */
    private static generatePriceResponse(product: any, emoji: string, links: any): string {
        let response = `El ${product.name} cuesta $${product.price.toLocaleString('es-CO')} COP ${emoji}\n\n`

        if (product.stock) {
            response += `Tenemos ${product.stock} unidades disponibles.\n`
        }

        if (links.buy) {
            response += `¬øDeseas el enlace de compra?`
        } else {
            response += `¬øDeseas m√°s informaci√≥n o hacer el pedido?`
        }

        return response
    }

    /**
     * Generar respuesta de LINK
     */
    private static generateLinkResponse(product: any, emoji: string, links: any): string {
        // Productos f√≠sicos: SIEMPRE contacto directo
        if (product.category === 'PHYSICAL') {
            return `Para adquirir ${product.name} ${emoji}, cont√°ctanos directamente:\n\nüìû WhatsApp: +57 304 274 8687\nüìß deinermen25@gmail.com\nüìç Centro Comercial El Diamante 2, San Nicol√°s, Cali\n\nM√©todos de pago:\n‚úÖ Efectivo\n‚úÖ Transferencia\n‚úÖ Nequi/Daviplata\n‚úÖ Tarjeta`
        }

        // Productos digitales: Verificar si tiene links
        if (!links.buy && !links.mercadopago && !links.paypal) {
            return `Para adquirir ${product.name} ${emoji}, cont√°ctanos:\n\nüì± WhatsApp: +57 304 274 8687\nüìß deinermen25@gmail.com`
        }

        let response = `¬°Perfecto! ${emoji}\n\n`

        if (links.buy) {
            response += `Aqu√≠ est√° el enlace de compra:\nüëâ ${links.buy}\n\n`
        }

        if (links.mercadopago && !links.buy) {
            response += `Mercado Pago:\nüëâ ${links.mercadopago}\n\n`
        }

        if (links.info) {
            response += `Tambi√©n puedes ver m√°s info aqu√≠:\nüìÑ ${links.info}\n\n`
        }

        response += `Acceso inmediato despu√©s del pago ‚úÖ`

        return response
    }

    /**
     * Generar respuesta de COMPRA
     */
    private static generateBuyResponse(product: any, emoji: string, links: any): string {
        let response = `¬°Excelente decisi√≥n! üéâ\n\n`
        response += `${product.name}: ${product.price.toLocaleString('es-CO')} COP\n\n`

        // Productos f√≠sicos: SIEMPRE contacto directo
        if (product.category === 'PHYSICAL') {
            response += `Para hacer tu pedido:\nüì± WhatsApp: +57 304 274 8687\nüìß deinermen25@gmail.com\nüìç Centro Comercial El Diamante 2, San Nicol√°s, Cali\n\nM√©todos de pago:\n‚úÖ Efectivo\n‚úÖ Transferencia\n‚úÖ Nequi/Daviplata\n‚úÖ Tarjeta`
            return response
        }

        // Productos digitales: Verificar links
        if (links.buy) {
            response += `Compra aqu√≠:\nüëâ ${links.buy}\n\n`
            response += `Acceso inmediato despu√©s del pago ‚úÖ`
        } else if (links.mercadopago) {
            response += `Compra aqu√≠:\nüëâ ${links.mercadopago}\n\n`
            response += `Acceso inmediato despu√©s del pago ‚úÖ`
        } else {
            response += `Para hacer tu pedido:\nüì± WhatsApp: +57 304 274 8687\nüìß deinermen25@gmail.com\n\n`
            response += `¬øNecesitas ayuda con algo m√°s?`
        }

        return response
    }

    /**
     * Generar respuesta de DISPONIBILIDAD
     */
    private static generateAvailabilityResponse(product: any, emoji: string): string {
        let response = `${emoji} ${product.name}\n\n`

        if (product.stock && product.stock > 0) {
            response += `‚úÖ Disponible: ${product.stock} unidad${product.stock > 1 ? 'es' : ''}\n\n`
            response += `¬øTe gustar√≠a hacer el pedido?`
        } else if (product.category === 'DIGITAL') {
            response += `‚úÖ Disponible (producto digital)\n\n`
            response += `Acceso inmediato despu√©s de la compra`
        } else {
            response += `‚ö†Ô∏è Consultar disponibilidad\n\n`
            response += `Cont√°ctanos para verificar stock:\nüì± +57 304 274 8687`
        }

        return response
    }

    /**
     * Generar respuesta GENERAL
     */
    private static generateGeneralResponse(product: any, emoji: string, links: any, images: string[]): string {
        let response = `${emoji} **${product.name}**\n\n`
        response += `üí∞ $${product.price.toLocaleString('es-CO')} COP\n`

        if (product.stock) {
            response += `üì¶ ${product.stock} disponibles\n`
        }

        if (images.length > 0) {
            response += `üì∏ ${images.length} fotos\n`
        }

        response += `\n¬øQu√© te gustar√≠a saber?`

        return response
    }

    /**
     * Obtener emoji seg√∫n el producto
     */
    private static getProductEmoji(product: any): string {
        const name = product.name.toLowerCase()

        if (name.includes('piano') || name.includes('m√∫sica')) return 'üéπ'
        if (name.includes('laptop') || name.includes('computador')) return 'üíª'
        if (name.includes('macbook') || name.includes('apple')) return 'üçé'
        if (name.includes('moto') || name.includes('pulsar')) return 'üèçÔ∏è'
        if (name.includes('curso') || name.includes('mega pack')) return 'üìö'
        if (name.includes('memoria') || name.includes('ram')) return 'üíæ'
        if (name.includes('ssd') || name.includes('disco')) return 'üíø'
        if (name.includes('morral') || name.includes('mochila')) return 'üéí'

        return '‚ú®'
    }

    /**
     * Extraer informaci√≥n estructurada del producto para la IA
     */
    static extractProductInfo(product: any): any {
        return {
            name: product.name,
            price: product.price,
            priceFormatted: `$${product.price.toLocaleString('es-CO')} COP`,
            category: product.category,
            description: product.description || '',
            stock: product.stock,
            images: this.extractImages(product),
            links: this.extractLinks(product),
            emoji: this.getProductEmoji(product),
            isDigital: product.category === 'DIGITAL',
            isPhysical: product.category === 'PHYSICAL'
        }
    }

    /**
     * Generar respuesta est√°tica como fallback (si falla la IA)
     */
    static generateStaticResponse(product: any, intent: any): string {
        const emoji = this.getProductEmoji(product)
        const links = this.extractLinks(product)

        switch (intent.type) {
            case 'info':
                return `${emoji} ${product.name}\n\nüí∞ $${product.price.toLocaleString('es-CO')} COP\n\n${product.description || 'Excelente producto disponible'}\n\n¬øTe interesa?`

            case 'price':
                return `${emoji} ${product.name} cuesta $${product.price.toLocaleString('es-CO')} COP\n\n¬øDeseas m√°s informaci√≥n?`

            case 'link':
                if (links.buy) {
                    return `¬°Perfecto! ${emoji}\n\nEnlace de compra:\n${links.buy}\n\n¬øAlguna duda?`
                }
                return `Para adquirir ${product.name}, cont√°ctanos:\nüì± +57 304 274 8687`

            case 'buy':
                return `¬°Excelente! ${emoji}\n\n${product.name}: $${product.price.toLocaleString('es-CO')} COP\n\n¬øConfirmamos tu pedido?`

            default:
                return `${emoji} ${product.name} - $${product.price.toLocaleString('es-CO')} COP\n\n¬øQu√© te gustar√≠a saber?`
        }
    }

    /**
     * üéØ DETECTAR SI ES UNA B√öSQUEDA GENERAL (sin especificaciones)
     * Ejemplo: "port√°tiles", "laptops", "motos", "cursos"
     */
    static isGeneralProductQuery(query: string, keywords: string[]): boolean {
        const queryLower = query.toLowerCase()
        
        // T√©rminos generales de categor√≠as
        const generalTerms = [
            'portatil', 'port√°til', 'portatiles', 'port√°tiles',
            'laptop', 'laptops', 'computador', 'computadora',
            'moto', 'motos', 'motocicleta',
            'curso', 'cursos', 'capacitacion', 'capacitaci√≥n',
            'megapack', 'mega pack', 'paquete',
            'producto', 'productos', 'articulo', 'art√≠culo'
        ]
        
        // T√©rminos espec√≠ficos que indican que NO es general
        const specificTerms = [
            'asus', 'hp', 'lenovo', 'dell', 'acer', 'macbook',
            'bajaj', 'pulsar', 'yamaha', 'honda',
            'i3', 'i5', 'i7', 'ryzen', 'core',
            '8gb', '16gb', '256gb', '512gb', '1tb',
            'usado', 'nueva', 'nuevo'
        ]
        
        // Si tiene t√©rminos espec√≠ficos, NO es general
        const hasSpecificTerms = specificTerms.some(term => queryLower.includes(term))
        if (hasSpecificTerms) {
            return false
        }
        
        // Si tiene t√©rminos generales y pocas palabras clave, ES general
        const hasGeneralTerms = generalTerms.some(term => queryLower.includes(term))
        const fewKeywords = keywords.length <= 2
        
        return hasGeneralTerms && fewKeywords
    }

    /**
     * üîç BUSCAR M√öLTIPLES PRODUCTOS DE UNA CATEGOR√çA
     */
    static async findProductsByCategory(
        query: string,
        userId: string,
        limit: number = 5
    ): Promise<any[]> {
        try {
            const queryLower = query.toLowerCase()
            
            // Determinar categor√≠a
            let category = ''
            if (queryLower.includes('portatil') || queryLower.includes('laptop') || queryLower.includes('computador')) {
                category = 'port√°til'
            } else if (queryLower.includes('moto')) {
                category = 'moto'
            } else if (queryLower.includes('curso')) {
                category = 'curso'
            } else if (queryLower.includes('megapack') || queryLower.includes('mega pack')) {
                category = 'megapack'
            }
            
            if (!category) {
                return []
            }
            
            console.log(`üì¶ [Product Intelligence] Buscando productos de categor√≠a: ${category}`)
            
            // Buscar productos de esa categor√≠a
            const products = await db.product.findMany({
                where: {
                    userId,
                    status: 'AVAILABLE',
                    OR: [
                        { name: { contains: category, mode: 'insensitive' } },
                        { description: { contains: category, mode: 'insensitive' } },
                        { category: { contains: category, mode: 'insensitive' } }
                    ]
                },
                take: limit,
                orderBy: { createdAt: 'desc' }
            })
            
            console.log(`‚úÖ [Product Intelligence] Encontrados ${products.length} productos de ${category}`)
            return products
            
        } catch (error) {
            console.error('[Product Intelligence] Error buscando por categor√≠a:', error)
            return []
        }
    }

    /**
     * üí¨ GENERAR PREGUNTAS DE CALIFICACI√ìN
     * Para entender mejor qu√© busca el cliente
     */
    static generateQualificationQuestions(query: string, products: any[]): string {
        const queryLower = query.toLowerCase()
        
        // Detectar categor√≠a
        let category = ''
        let questions: string[] = []
        
        if (queryLower.includes('portatil') || queryLower.includes('laptop') || queryLower.includes('computador')) {
            category = 'port√°tiles'
            questions = [
                '¬øPara qu√© lo vas a usar principalmente? (trabajo, estudio, gaming, dise√±o)',
                '¬øTienes alg√∫n presupuesto en mente?',
                '¬øPrefieres alguna marca en particular? (Asus, HP, Lenovo, etc.)'
            ]
        } else if (queryLower.includes('moto')) {
            category = 'motos'
            questions = [
                '¬øBuscas moto nueva o usada?',
                '¬øQu√© cilindraje prefieres?',
                '¬øPara qu√© la vas a usar? (trabajo, paseo, ciudad)'
            ]
        } else if (queryLower.includes('curso')) {
            category = 'cursos'
            questions = [
                '¬øQu√© tema te interesa aprender?',
                '¬øNivel principiante o avanzado?'
            ]
        } else if (queryLower.includes('megapack') || queryLower.includes('mega pack')) {
            category = 'megapacks'
            questions = [
                '¬øBuscas un megapack espec√≠fico o el paquete completo con todos?',
                '¬øQu√© tipo de contenido te interesa m√°s?'
            ]
        }
        
        // Construir respuesta
        let response = `¬°Claro que s√≠! Tenemos varios ${category} disponibles. üòä\n\n`
        
        // Mostrar cantidad
        if (products.length > 0) {
            response += `Actualmente tenemos ${products.length} opciones de ${category}.\n\n`
        }
        
        // Agregar preguntas
        response += `Para recomendarte la mejor opci√≥n, cu√©ntame:\n\n`
        questions.forEach((q, i) => {
            response += `${i + 1}. ${q}\n`
        })
        
        response += `\nAs√≠ puedo mostrarte exactamente lo que necesitas. üí°`
        
        return response
    }
}
