/**
 * üè∑Ô∏è PRODUCT TAG SERVICE
 * Servicio inteligente para generar y gestionar tags de productos
 */

export interface ProductTagSuggestion {
  tag: string
  description: string
  confidence: number
  category?: string
}

export interface ProductTagConfig {
  name: string
  description: string
  category: string
  tags: string[]
  searchPriority: number
  autoGenerated: boolean
  metadata?: Record<string, any>
}

export class ProductTagService {
  private static readonly CATEGORY_TEMPLATES: Record<string, { tags: string[], searchTerms: string[] }> = {
    'cursos': {
      tags: ['educacion', 'aprendizaje', 'online', 'clases'],
      searchTerms: ['curso de', 'clases de', 'aprende', 'tutorial']
    },
    'musica': {
      tags: ['instrumentos', 'audio', 'melodia', 'ritmo'],
      searchTerms: ['aprender musica', 'clases de piano', 'guitarra']
    },
    'idiomas': {
      tags: ['lenguas', 'habla', 'bilingue', 'fluidez'],
      searchTerms: ['aprende ingles', 'curso de idiomas', 'clases de espa√±ol']
    },
    'diseno': {
      tags: ['creatividad', 'grafico', 'visual', 'arte'],
      searchTerms: ['dise√±o grafico', 'photoshop', 'illustrator']
    },
    'programacion': {
      tags: ['desarrollo', 'codigo', 'software', 'tech'],
      searchTerms: ['aprende a programar', 'curso javascript', 'python']
    },
    'marketing': {
      tags: ['ventas', 'ads', 'social', 'estrategia'],
      searchTerms: ['ventas online', 'marketing digital', 'facebook ads']
    },
    'fotografia': {
      tags: ['camara', 'lente', 'edicion', 'captura'],
      searchTerms: ['curso de fotografia', 'edicion de fotos']
    },
    'video': {
      tags: ['produccion', 'cine', 'edicion', 'clip'],
      searchTerms: ['edicion de video', 'creacion de contenido']
    },
    'negocios': {
      tags: ['finanzas', 'emprender', 'gestion', 'pymes'],
      searchTerms: ['crear negocio', 'gestion empresarial']
    },
    'tecnologia': {
      tags: ['gadgets', 'computacion', 'digital', 'avanzado'],
      searchTerms: ['tecnologia moderna', 'computadoras', 'it']
    }
  }

  /**
   * Generate tag suggestions for a product
   */
  static generateTagSuggestions(product: {
    name: string
    description?: string
    category?: string
    price?: number
  }): ProductTagSuggestion[] {
    const suggestions: ProductTagSuggestion[] = []
    const text = `${product.name} ${product.description || ''}`.toLowerCase()

    // Category-based tags
    if (product.category) {
      suggestions.push({
        tag: product.category,
        description: `Categor√≠a principal`,
        confidence: 1.0,
        category: 'category'
      })
    }

    // Extract keywords from name and description
    const keywords = this.extractKeywords(text)
    keywords.forEach(keyword => {
      suggestions.push({
        tag: keyword,
        description: `Palabra clave detectada`,
        confidence: 0.8,
        category: 'keyword'
      })
    })

    // Price-based tags
    if (product.price) {
      const priceTag = this.getPriceRangeTag(product.price)
      if (priceTag) {
        suggestions.push({
          tag: priceTag,
          description: `Rango de precio`,
          confidence: 0.9,
          category: 'price'
        })
      }
    }

    // Common product type tags
    const productTypes = this.detectProductType(text)
    productTypes.forEach(type => {
      suggestions.push({
        tag: type,
        description: `Tipo de producto detectado`,
        confidence: 0.85,
        category: 'type'
      })
    })

    return suggestions.sort((a, b) => b.confidence - a.confidence)
  }

  /**
   * Generate complete product configuration
   */
  static generateProductConfig(product: {
    name: string
    description?: string
    category?: string
    tags?: string[]
    price?: number
  }): ProductTagConfig {
    const suggestions = this.generateTagSuggestions(product)
    const autoTags = suggestions
      .filter(s => s.confidence >= 0.7)
      .map(s => s.tag)
      .slice(0, 10)

    const allTags = [...new Set([...(product.tags || []), ...autoTags])]

    return {
      name: product.name,
      description: product.description || '',
      category: product.category || this.detectCategory(product.name),
      tags: allTags,
      searchPriority: this.calculateSearchPriority(allTags.length, product.description?.length || 0),
      autoGenerated: true,
      metadata: {
        generatedAt: new Date().toISOString()
      }
    }
  }

  /**
   * Validate tag configuration
   */
  static validateTagConfig(config: ProductTagConfig): {
    isValid: boolean
    warnings: string[]
    suggestions: string[]
  } {
    const warnings: string[] = []
    const suggestions: string[] = []

    if (config.tags.length < 3) {
      warnings.push('Se recomiendan al menos 3 tags para mejor b√∫squeda')
      suggestions.push('Agrega m√°s palabras clave relacionadas con tu producto')
    }

    if (config.tags.length > 15) {
      warnings.push('Demasiados tags pueden reducir la relevancia')
      suggestions.push('Considera reducir a los 10-12 tags m√°s importantes')
    }

    if (!config.category) {
      warnings.push('No se ha definido una categor√≠a')
      suggestions.push('Selecciona una categor√≠a para mejorar la organizaci√≥n')
    }

    const duplicates = this.findDuplicateTags(config.tags)
    if (duplicates.length > 0) {
      warnings.push(`Tags duplicados encontrados: ${duplicates.join(', ')}`)
      suggestions.push('Elimina los tags duplicados')
    }

    return {
      isValid: warnings.length === 0,
      warnings,
      suggestions
    }
  }

  /**
   * Optimize tags by removing duplicates and low-value tags
   */
  static optimizeTags(tags: string[]): string[] {
    // Remove duplicates (case-insensitive)
    const uniqueTags = [...new Set(tags.map(t => t.toLowerCase()))]
    
    // Remove very short tags (less than 2 characters)
    const filtered = uniqueTags.filter(tag => tag.length >= 2)
    
    // Remove common stop words
    const stopWords = ['el', 'la', 'de', 'del', 'y', 'o', 'un', 'una']
    const optimized = filtered.filter(tag => !stopWords.includes(tag))
    
    return optimized.slice(0, 12) // Limit to 12 tags
  }

  // Private helper methods

  private static extractKeywords(text: string): string[] {
    const words = text.split(/\s+/)
    const keywords = words.filter(word => 
      word.length > 3 && 
      !this.isCommonWord(word)
    )
    return [...new Set(keywords)].slice(0, 8)
  }

  private static isCommonWord(word: string): boolean {
    const commonWords = [
      'para', 'con', 'por', 'sin', 'sobre', 'entre', 'desde', 'hasta',
      'the', 'and', 'for', 'with', 'from', 'this', 'that', 'have'
    ]
    return commonWords.includes(word.toLowerCase())
  }

  private static getPriceRangeTag(price: number): string | null {
    if (price < 50) return 'econ√≥mico'
    if (price < 100) return 'precio-medio'
    if (price < 500) return 'premium'
    return 'lujo'
  }

  private static detectProductType(text: string): string[] {
    const types: string[] = []

    const typePatterns = {
      'curso': /curso|capacitaci√≥n|formaci√≥n|entrenamiento/i,
      'digital': /digital|online|virtual|descarga/i,
      'f√≠sico': /f√≠sico|material|env√≠o|entrega/i,
      'software': /software|programa|aplicaci√≥n|app/i,
      'ebook': /ebook|libro|gu√≠a|manual/i,
      'video': /video|tutorial|clase|lecci√≥n/i,
      'audio': /audio|podcast|m√∫sica|sonido/i
    }

    Object.entries(typePatterns).forEach(([type, pattern]) => {
      if (pattern.test(text)) {
        types.push(type)
      }
    })

    return types
  }

  private static detectCategory(productName: string): string {
    const name = productName.toLowerCase()

    const categoryPatterns: Record<string, RegExp> = {
      'cursos': /curso|capacitaci√≥n|formaci√≥n/i,
      'musica': /m√∫sica|piano|guitarra|instrumento/i,
      'idiomas': /ingl√©s|espa√±ol|idioma|language/i,
      'diseno': /dise√±o|photoshop|illustrator/i,
      'programacion': /programaci√≥n|c√≥digo|desarrollo|javascript|python/i,
      'marketing': /marketing|ventas|publicidad/i,
      'fotografia': /fotograf√≠a|foto|c√°mara/i,
      'video': /video|edici√≥n|premiere/i,
      'negocios': /negocio|empresa|emprendimiento/i,
      'tecnologia': /tecnolog√≠a|tech|software/i
    }

    for (const [category, pattern] of Object.entries(categoryPatterns)) {
      if (pattern.test(name)) {
        return category
      }
    }

    return 'general'
  }

  private static calculateSearchPriority(tagCount: number, descriptionLength: number): number {
    let priority = 5 // Base priority

    // More tags = higher priority
    if (tagCount >= 8) priority += 2
    else if (tagCount >= 5) priority += 1

    // Longer description = higher priority
    if (descriptionLength > 200) priority += 2
    else if (descriptionLength > 100) priority += 1

    return Math.min(priority, 10) // Cap at 10
  }

  private static findDuplicateTags(tags: string[]): string[] {
    const seen = new Set<string>()
    const duplicates = new Set<string>()

    tags.forEach(tag => {
      const normalized = tag.toLowerCase()
      if (seen.has(normalized)) {
        duplicates.add(tag)
      }
      seen.add(normalized)
    })

    return Array.from(duplicates)
  }
}
