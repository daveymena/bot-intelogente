/**
 * üè∑Ô∏è SERVICIO DE TAGS INTELIGENTES PARA PRODUCTOS
 * Sistema SaaS que facilita la configuraci√≥n de productos para clientes
 * Genera tags autom√°ticamente y sugiere configuraciones √≥ptimas
 */

export interface ProductTagSuggestion {
  tag: string;
  category: string;
  confidence: number;
  description: string;
  searchTerms: string[];
}

export interface ProductTagConfig {
  name: string;
  description: string;
  category: string;
  tags: string[];
  searchPriority: number;
  autoGenerated: boolean;
}

export class ProductTagService {
  /**
   * Categor√≠as predefinidas con sus tags inteligentes
   */
  private static readonly CATEGORY_TEMPLATES = {
    'cursos': {
      tags: ['curso', 'capacitaci√≥n', 'aprendizaje', 'educaci√≥n', 'formaci√≥n'],
      searchTerms: ['curso de', 'aprender', 'ense√±ar', 'clases de', 'capacitaci√≥n en']
    },
    'musica': {
      tags: ['m√∫sica', 'musical', 'instrumento', 'audio', 'producci√≥n'],
      searchTerms: ['piano', 'guitarra', 'bater√≠a', 'canto', 'producci√≥n musical', 'mezcla', 'mastering']
    },
    'idiomas': {
      tags: ['idioma', 'language', 'conversaci√≥n', 'gram√°tica', 'vocabulario'],
      searchTerms: ['ingl√©s', 'espa√±ol', 'franc√©s', 'alem√°n', 'italiano', 'chino', 'japon√©s', 'portugu√©s']
    },
    'diseno': {
      tags: ['dise√±o', 'gr√°fico', 'creativo', 'visual', 'arte'],
      searchTerms: ['photoshop', 'illustrator', 'indesign', 'corel', 'dise√±o web', 'logo', 'branding']
    },
    'programacion': {
      tags: ['programaci√≥n', 'c√≥digo', 'desarrollo', 'software', 'web'],
      searchTerms: ['javascript', 'python', 'java', 'php', 'react', 'node', 'html', 'css', 'mysql']
    },
    'marketing': {
      tags: ['marketing', 'ventas', 'publicidad', 'redes sociales', 'estrategia'],
      searchTerms: ['facebook ads', 'google ads', 'seo', 'sem', 'email marketing', 'social media']
    },
    'fotografia': {
      tags: ['fotograf√≠a', 'foto', 'imagen', 'c√°mara', 'edici√≥n'],
      searchTerms: ['lightroom', 'photoshop', 'edici√≥n', 'retrato', 'paisaje', 'producto']
    },
    'video': {
      tags: ['video', 'edici√≥n', 'producci√≥n', 'cine', 'audiovisual'],
      searchTerms: ['premiere', 'after effects', 'final cut', 'da vinci', 'edici√≥n video']
    },
    'negocios': {
      tags: ['negocio', 'emprendimiento', 'empresa', 'finanzas', 'estrategia'],
      searchTerms: ['emprender', 'empresa', 'finanzas', 'contabilidad', 'administraci√≥n']
    },
    'salud': {
      tags: ['salud', 'bienestar', 'fitness', 'nutrici√≥n', 'mente'],
      searchTerms: ['gimnasio', 'nutrici√≥n', 'meditaci√≥n', 'yoga', 'psicolog√≠a']
    },
    'tecnologia': {
      tags: ['tecnolog√≠a', 'hardware', 'software', 'gadgets', 'innovaci√≥n'],
      searchTerms: ['computador', 'laptop', 'celular', 'tablet', 'impresora']
    }
  };

  /**
   * Genera sugerencias de tags inteligentes para un producto
   */
  static generateTagSuggestions(product: {
    name: string;
    description?: string;
    category?: string;
  }): ProductTagSuggestion[] {
    const suggestions: ProductTagSuggestion[] = [];
    const text = `${product.name} ${product.description || ''}`.toLowerCase();

    // Analizar por categor√≠as existentes
    for (const [categoryKey, categoryData] of Object.entries(this.CATEGORY_TEMPLATES)) {
      let categoryScore = 0;
      const matchedTerms: string[] = [];

      // Verificar coincidencias en el texto del producto
      for (const term of categoryData.searchTerms) {
        if (text.includes(term.toLowerCase())) {
          categoryScore += 20;
          matchedTerms.push(term);
        }
      }

      // Verificar tags de categor√≠a
      for (const tag of categoryData.tags) {
        if (text.includes(tag.toLowerCase())) {
          categoryScore += 15;
          matchedTerms.push(tag);
        }
      }

      // Si hay buena coincidencia, agregar sugerencia
      if (categoryScore >= 15) {
        suggestions.push({
          tag: categoryKey,
          category: categoryKey,
          confidence: Math.min(categoryScore / 100, 1),
          description: `Categor√≠a ${categoryKey} - t√©rminos encontrados: ${matchedTerms.slice(0, 3).join(', ')}`,
          searchTerms: matchedTerms
        });
      }
    }

    // Analizar palabras clave espec√≠ficas del producto
    const specificTags = this.extractSpecificTags(text);
    suggestions.push(...specificTags);

    // Ordenar por confianza
    return suggestions.sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Extrae tags espec√≠ficos del texto del producto
   */
  private static extractSpecificTags(text: string): ProductTagSuggestion[] {
    const tags: ProductTagSuggestion[] = [];
    const words = text.split(/\s+/).filter(w => w.length > 3);

    // Buscar t√©rminos t√©cnicos espec√≠ficos
    const technicalTerms = [
      'javascript', 'python', 'react', 'node', 'php', 'java', 'mysql', 'mongodb',
      'photoshop', 'illustrator', 'premiere', 'lightroom', 'after effects',
      'facebook', 'instagram', 'google', 'ads', 'seo', 'sem',
      'piano', 'guitarra', 'bateria', 'canto', 'voz',
      'ingles', 'espa√±ol', 'frances', 'aleman', 'italiano', 'chino',
      'marketing', 'ventas', 'publicidad', 'branding', 'logo'
    ];

    for (const term of technicalTerms) {
      if (text.includes(term)) {
        tags.push({
          tag: term,
          category: this.guessCategoryFromTerm(term),
          confidence: 0.8,
          description: `T√©rmino t√©cnico espec√≠fico: ${term}`,
          searchTerms: [term]
        });
      }
    }

    return tags;
  }

  /**
   * Adivina la categor√≠a basada en un t√©rmino
   */
  private static guessCategoryFromTerm(term: string): string {
    const categoryMap: Record<string, string> = {
      'javascript': 'programacion',
      'python': 'programacion',
      'react': 'programacion',
      'node': 'programacion',
      'php': 'programacion',
      'java': 'programacion',
      'mysql': 'programacion',
      'mongodb': 'programacion',
      'photoshop': 'diseno',
      'illustrator': 'diseno',
      'premiere': 'video',
      'lightroom': 'fotografia',
      'facebook': 'marketing',
      'instagram': 'marketing',
      'google': 'marketing',
      'seo': 'marketing',
      'sem': 'marketing',
      'piano': 'musica',
      'guitarra': 'musica',
      'bateria': 'musica',
      'canto': 'musica',
      'ingles': 'idiomas',
      'espa√±ol': 'idiomas',
      'frances': 'idiomas',
      'aleman': 'idiomas'
    };

    return categoryMap[term] || 'general';
  }

  /**
   * Genera configuraci√≥n completa para un producto
   */
  static generateProductConfig(product: {
    name: string;
    description?: string;
    category?: string;
    price?: number;
  }): ProductTagConfig {
    const suggestions = this.generateTagSuggestions(product);
    const primarySuggestion = suggestions[0];

    // Generar tags basados en sugerencias
    const tags = new Set<string>();

    // Agregar tags de la categor√≠a principal
    if (primarySuggestion) {
      tags.add(primarySuggestion.tag);
      const categoryData = this.CATEGORY_TEMPLATES[primarySuggestion.category as keyof typeof this.CATEGORY_TEMPLATES];
      if (categoryData) {
        categoryData.tags.forEach(tag => tags.add(tag));
      }
    }

    // Agregar tags espec√≠ficos encontrados
    suggestions.forEach(suggestion => {
      suggestion.searchTerms.forEach(term => tags.add(term));
    });

    // Agregar tags del nombre del producto
    const nameWords = product.name.toLowerCase().split(/\s+/).filter(w => w.length > 3);
    nameWords.forEach(word => tags.add(word));

    return {
      name: product.name,
      description: product.description || '',
      category: primarySuggestion?.category || product.category || 'general',
      tags: Array.from(tags),
      searchPriority: primarySuggestion ? Math.round(primarySuggestion.confidence * 10) : 5,
      autoGenerated: true
    };
  }

  /**
   * Valida configuraci√≥n de tags
   */
  static validateTagConfig(config: ProductTagConfig): {
    isValid: boolean;
    warnings: string[];
    suggestions: string[];
  } {
    const warnings: string[] = [];
    const suggestions: string[] = [];

    // Verificar que tenga al menos 3 tags
    if (config.tags.length < 3) {
      warnings.push('Se recomienda tener al menos 3 tags para mejor b√∫squeda');
      suggestions.push('Agregue m√°s tags relacionados con su producto');
    }

    // Verificar que tenga tags de b√∫squeda comunes
    const hasSearchTerms = config.tags.some(tag =>
      this.CATEGORY_TEMPLATES[config.category as keyof typeof this.CATEGORY_TEMPLATES]?.searchTerms.some(term =>
        tag.toLowerCase().includes(term.toLowerCase())
      )
    );

    if (!hasSearchTerms) {
      warnings.push('Considere agregar t√©rminos de b√∫squeda comunes para su categor√≠a');
      const categoryData = this.CATEGORY_TEMPLATES[config.category as keyof typeof this.CATEGORY_TEMPLATES];
      if (categoryData) {
        suggestions.push(`T√©rminos sugeridos: ${categoryData.searchTerms.slice(0, 3).join(', ')}`);
      }
    }

    // Verificar duplicados
    const uniqueTags = new Set(config.tags.map(t => t.toLowerCase()));
    if (uniqueTags.size !== config.tags.length) {
      warnings.push('Hay tags duplicados (diferentes solo en may√∫sculas/min√∫sculas)');
      suggestions.push('Elimine los tags duplicados');
    }

    return {
      isValid: warnings.length === 0,
      warnings,
      suggestions
    };
  }

  /**
   * Optimiza tags para mejor b√∫squeda
   */
  static optimizeTags(tags: string[]): string[] {
    const optimized = new Set<string>();

    tags.forEach(tag => {
      const normalized = tag.toLowerCase().trim();

      // Agregar el tag normalizado
      optimized.add(normalized);

      // Agregar variaciones comunes
      if (normalized.endsWith('s') && normalized.length > 3) {
        optimized.add(normalized.slice(0, -1)); // Singular
      }

      // Agregar sin acentos
      const withoutAccents = normalized.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      if (withoutAccents !== normalized) {
        optimized.add(withoutAccents);
      }
    });

    return Array.from(optimized);
  }

  /**
   * Obtiene estad√≠sticas de uso de tags
   */
  static getTagStats(products: Array<{ tags: string[] }>): {
    mostUsed: Array<{ tag: string; count: number }>;
    coverage: number;
    recommendations: string[];
  } {
    const tagCounts = new Map<string, number>();

    products.forEach(product => {
      product.tags.forEach(tag => {
        const normalized = tag.toLowerCase();
        tagCounts.set(normalized, (tagCounts.get(normalized) || 0) + 1);
      });
    });

    const mostUsed = Array.from(tagCounts.entries())
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    const totalProducts = products.length;
    const productsWithTags = products.filter(p => p.tags.length > 0).length;
    const coverage = totalProducts > 0 ? (productsWithTags / totalProducts) * 100 : 0;

    const recommendations: string[] = [];
    if (coverage < 70) {
      recommendations.push('Considere agregar m√°s tags a sus productos para mejorar la b√∫squeda');
    }
    if (mostUsed.length < 5) {
      recommendations.push('Diversifique los tags para cubrir m√°s t√©rminos de b√∫squeda');
    }

    return {
      mostUsed,
      coverage,
      recommendations
    };
  }
}